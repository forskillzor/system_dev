Содержание

1 Введение

2 Установка программного обеспечения

3 Низкоуровневая системная информация
  3.1 Машинный интерфейс
    3.1.1 Архитектура процессора
    3.1.2 Представление данных
  3.2 Последовательность вызова функции
    3.2.1 Регистры и стековый кадр
    3.2.2 Стековый кадр
    3.2.3 Передача параметров
  3.3 Интерфейс операционной системы
    3.3.1 Интерфейс прерываний
    3.3.2 Виртуальное адресное пространство
    3.3.3 Размер страниц
    3.3.4 Назначение виртуальных адрессов
  3.4 Инициализация процесса
    3.4.1 Начальное состояние стека и регистров
    3.4.2 Состояние потока
    3.4.3 Вспомогательный вектор
  3.5 Примеры кода
    3.5.1 Архитектурные ограничения
    3.5.2 Соглашения
    3.5.3 Позиционно-независимый пролог функции
    3.5.4 Объекты данных
    3.5.5 Вызовы функций
    3.5.6 Ветвление
    3.5.7 Списки аргументов
  3.6 DWARF Соглашение
    3.6.1 DWARF номер выпуска
    3.6.2 DWARF маппинг номеров регистров
  3.7 Алгоритм разматывания стека

4 Объектные файлы
  4.1 ELF Header
    4.1.1 Машинная информация
    4.1.2 Число программных заголовков
  4.2 Секции
    4.2.1 Флаги секции
    4.2.2 Типы секций
    4.2.3 Специальные секции
    4.2.4 EH_FRAME секции
  4.3 Таблица символов
  4.4 Перемещение
    4.4.1 Типы перемещений
    4.4.2 Большие модели

5 Загрузка программы и динамическое связывание    
  5.1 Загрузка программы
    5.1.1 Программный заголовок
  5.2 Динамическое связывание
    5.2.1 Программный интерпретатор 
    5.2.2 Функции инициализации и завершения

6 Библиотеки
  6.1 Библиотека С
    6.1.1 Символы глобальных данных
    6.1.2 Функции с плавающей точкой
  6.2 Размотка бибилиотечного интерфейса
    6.2.1 Фреймвор обработки исключений
    6.2.2 Структуры данных
    6.2.3 Выброс исключений
    6.2.4 Управление объектами исключений
    6.2.5 Управление контекстом
    6.2.6 Персональные рутины
  6.3 Разматывание через ассемблерный код

7 Среда разработки

8 Среда выполнения

9 Соглашения
  9.1 C++
  9.2 Fortran
    9.2.1 Имена
    9.2.2 Представление типов Fortran
    9.2.3 Передача аргументов
    9.2.4 Функции
    9.2.5 COMMON блоки
    9.2.6 Встраивания

10 ILP32 Программная модель
  10.1 Передача параметров
  10.2 Адрессное пространство
  10.3 Поддержка локального потока
    10.3.1 Глобальная переменная локального потока
    10.3.2 Статическая переменная локального потока
    10.3.3 TLS оптимизация компоновщика
  10.4 Поддержка ядра
  10.5 Примеры кода
    10.5.1 Косвенная ветвь



    Глава 1

    Введение

  Архитектура AMD64 является расширением архитектуры x86. Любой 
процессор реализация спецификации архитектуры AMD64 также обеспечит
совместимость режимы работы для предыдущих потомков архитектуры 
Intel 8086, включая 32-разрядные процессоры, такие как Intel 386, 
Intel Pentium и AMD K6-2.
  Операционные системы, соответствующие AMD64 ABI, могут обеспечить 
поддержку для выполнения программы, которые предназначены для
выполнения в этих режимах совместимости. AMD64 ABI не распространяется
на такие программы; этот документ относится только к программам, 
запущенным в «long» режиме, предоставляемом архитектурой AMD64.

  Двоичные файлы, использующие набор инструкций AMD64, могут 
программироваться как на 32-битные модель, в которой типы данных
C int, long и все типы указателей являются 32-битными объекты (ILP32);
или к 64-битной модели, в которой тип C int является 32-битным,
но Тип C long и все типы указателей являются 64-битными объектами 
(LP64). Эта спецификация охватывает как модели программирования LP64,
так и ILP32.

  Если не указано иное, архитектура AMD64 ABI соответствует соглашениям,
описанным в Intel386 ABI. Вместо того, чтобы копировать все содержимое
из Intel386 ABI, AMD64 ABI указывает только те места, где изменения
были сделаны для Intel386 ABI.

Не было предпринято никаких попыток указать ABI для языков, отличных
от C. Тем не менее, предполагается, что многие языки программирования
захотят связать с кодом написаным на C, так что описанные здесь
спецификации ABI также применимы. 

    Глава 2

    Установка программого обеспечения

Данный документ не определяет каким образом программное обеспечение
должно быть установленно на архитектуру AMD64.

    Глава 3

    Низкоуровневая системная информация

    3.1 Машинный интерфейс
    3.1.1 Архитектура процессора
    3.1.2 Представление данных

В этой спецификации термин байт относится к 8-битному объекту, термин
двухбайтовый относится к 16-битному объекту, термин четырехбайтовый
относится к 32-битному объекту, термин восьмибайтный байт относится к
64-битному объекту, а термин шестнадцать байт относится к 128-битному
объекту. [1]

Фундаментальные типы

На рисунке 3.1 показано соответствие между скалярными типами ISO C
и процессорными.

__int128, __float80, __float128, __m64, __m128, __m256 и типы __m512
являются необязательными.
  Тип __float128 использует 15-битную экспоненту, 113-битную мантиссу
значимый бит порядка подразумевается) и смещение экспоненты 16383. [2]
  Тип long double использует 15-битную экспоненту, 64-битную мантиссу
с явным старшим значащим битом и смещением экспоненты 16383. [3]
Хотя long double требует 16 байтов памяти, только первые 10 байтов
значимы. оставшиеся шесть байтов являются хвостовыми дополнениями, и
содержимое этих байтов не определено.
_____________________________________________________________________
[1] Intel386 ABI использует термин полуслово для 16-битного объекта,
    термин слово для 32-битного объекта, термин двойное слово для
    64-битного объекта. Но большинство документации по процессору IA-32
    определяют слово как 16-битный объект, двойное слово как 32-битный
    объект, четверное слово как 64-битный объект и двойное четверное слово как 128-битный объект.
[2] Ожидается, что начальные реализации архитектуры AMD64 будут
    поддерживать операции с типом __float128 только через программную эмуляцию.
[3] Этот тип является типом данных x87 с двойной точностью.
_____________________________________________________________________

  Тип __int128 хранится в младшем порядке в памяти, то есть 64 биты
младшего разряда хранятся по более низкому адресу, чем 64 старших бита.
  Нулевой указатель (для всех типов) имеет значение ноль.
  Тип size_t определяется как unsigned long для LP64 и unsigned int для ILP32.
  Булевы значения при хранении в объекте памяти сохраняются как
однобайтовые объекты значение которого всегда равно 0 (false) или 1 (true).
При хранении в целочисленных регистрах (за исключением передачи в
качестве аргументов), все 8 байтов регистра значимы; Любые ненулевое
значение считается истинным.
  Как и архитектура Intel386, архитектура AMD64 в целом не требует
запрашивать все обращения к данным для правильного выравнивания.
Несовмещенный доступ к данным медленнее чем выровненный доступ, но в
остальном ведут себя одинаково. Единственными исключениями являются
что __m128, __m256 и __m512 всегда должны быть правильно выровнены.

        Рисунок 3.1: Скалярные типы
_______________________________________________________________________
Type                 C           sizeof   Alignment   AMD64 arch
_______________________________________________________________________
Integral    _Bool [1]                 1         1     boolean
            __________________________________________________________
            char                      1         1     signed byte
            signed char               
            __________________________________________________________
            unsigned char             1         1     unsigned byte
            __________________________________________________________
            short                     2         2     signed twobyte
            signed short             
            __________________________________________________________
            unsigned short            2         2     unsigned twobyte
            __________________________________________________________
            int                       4         4     signed fourbyte
            signed int             
            enum [3]         
            __________________________________________________________
            unsigned int              4         4     unsigned fourbyte
            __________________________________________________________
            long (LP64)               8         8     signed eightbyte
            signed long (LP64)        
            __________________________________________________________
            unsigned long (LP64)      8         8     unsigned eigthbyte
            __________________________________________________________
            long (ILP32)              4         4     signed fourbyte
            signed long (ILP32)       
            __________________________________________________________
            unsigned long (ILP32)     4         4     unsigned fourbyte
            __________________________________________________________
            long long                 8         8 [4] signed eightbyte
            signed long long          
            __________________________________________________________
            unsigned long long        8         8 [4] unsigned eightbyte
            __________________________________________________________
            _int128 [2]               16        16    signed sixteenbyte
            signed _int128 [2]         
            __________________________________________________________
            unsigned _int128          16        16    unsigned sixteenbyte
_______________________________________________________________________
Pointer     any-type * (LP64)         8         8     unsigned eightbyte
            any-type (*)() (LP64)
            __________________________________________________________
            any-type * (ILP32)        4         4     unsigned foutbute
            any-type (*)() (ILP32)
_______________________________________________________________________
Float       float                     4         4     single (IEEE-754)
            __________________________________________________________
            double                    8         8 [4] double (IEEE-754)
            __________________________________________________________
            _float80 [2]              16        16    80-bit extended
            long double [5]
            __________________________________________________________
            _float128 [2]             16        16    128-bit extended
            long double [5]           16        16    128-bit extended
_______________________________________________________________________
Decimal     _Decimal32  [2]           4         4   32bit BID IEEE-754R
floation    _Decimal64  [2]           8         8   64bit BID IEEE-754R
            _Decimal128 [2]          16        16  128bit BID IEEE-754R
_______________________________________________________________________
Packed      _m64                      8         8   MMX and 3DNow!
            _128                      16        16  SSE and SSE2
            _256                      32        32  AVX
            _512                      64        64  AVX-512
_______________________________________________________________________

[1] тип bool C++
[2] опциональные типы (необязательные)
[3] C ++ и некоторые реализации C позволяют перечислять больше, чем int.
    В указанном порядке базовый тип имеет значение без знака int, long
    int или unsigned long int.
[4] long long, signed long long, unsigned long long и double тип
    имеют 4-байтовое выравнивание в Intel386 ABI.
[5] Тип long double является 128-битным, таким же, как тип __float128,
    на Платформе Android TM.


Агрегаты и Объединения

Структуры и союзы предполагают выравнивание своих наиболее строго
выровненных компонент. Каждому участнику присваивается наименьшее
доступное смещение с соответствующим выравнивание. Размер любого
объекта всегда кратен выравниванию объекта.
  Массив использует то же выравнивание, что и его элементы, за
исключением того, что локальная или глобальная переменная массива
длиной не менее 16 байтов или переменная массива C99 переменной длины
всегда имеет выравнивание не менее 16 байтов. [4]
_______________________________________________________________________
[4] Требование выравнивания позволяет использовать инструкции SSE при
работе с массивом. Компилятор не может вообще вычислить размер массива
переменной длины (VLA), но предполагается, что большинству VLA
потребуется по крайней мере 16 байтов, поэтому логично предписать, что
VLA имеет минимум 16-байтовое выравнивание.
_______________________________________________________________________
  Объекты структуры и объединения могут требовать заполнения, чтобы
соответствовать размеру и выравниванию ограничения. Содержимое любого
отступа не определено.

Битовые поля

Определения структуры и объединения C могут включать битовые поля,
которые определяют целые значения указанного размера.
  ABI не разрешает битовые поля, имеющие тип __m64, __m128, __m256, __m512.
Программы, использующие битовые поля этих типов, не являются переносимыми.
        Рисунок 3.2 Диапазоны Битовых Полей
______________________________________________________________________
    Bit-field Type        Width w       Range
______________________________________________________________________
signed char               1 to 8      -2^(w-1) to 2^(w-1) -1
char                                  0 to 2^(w-1)
unsigned char                         0 to 2^(w-1)          
______________________________________________________________________
signed short              1 to 16     -2^(w-1) to 2^(w-1) -1
short                                 0 to 2^(w-1)
unsigned short                        0 to 2^(w-1)          
______________________________________________________________________
signed int                1 to 32     -2^(w-1) to 2^(w-1) -1
int                                   0 to 2^(w-1)
unsigned int                          0 to 2^(w-1)          
______________________________________________________________________
signed long (LP64)        1 to 64     -2^(w-1) to 2^(w-1) -1
long (LP64)                           0 to 2^(w-1)
unsigned long (LP64)                  0 to 2^(w-1)          
______________________________________________________________________
long (ILP32)              1 to 32     0 to 2^(w-1)
unsigned long (ILP32)                 0 to 2^(w-1)
______________________________________________________________________
signed long long          1 to 64     -2^(w-1) to 2^(w-1) -1
long long                             0 to 2^(w-1)
undigned long long                    0 to 2^(w-1)          
______________________________________________________________________

Битовые поля, знаковые и беззнаковые, всегда имеют неотрицательные значения.
Хотя они могут иметь тип char, short, int или long (которые могут иметь
относительные значения), эти битовые поля имеют тот же диапазон, что и 
битовое поле того же размера с соответствующим типом без знака. Битовые
поля подчиняются одинаковому размеру и правилам выравнивания как и
другие структуры и члены Объединения.
  Так же:
  * битовые поля выдуляются с права на лево
  * битовые поля должны храниться в блоке памяти соласно их определяющему типу
  * битовые поля могут совместно использовать единицу хранения с другими членами
    структуры / объединения 

Типы безымянных битовых полей не влияют на выравнивание структуры или объединения.

    3.2. Последовательность вызыва процедур
Типы безымянных битовых полей не влияют на выравнивание структуры или объединения.
В этом разделе описана стандартная последовательность вызова функций,
включая стековый кадр, использование регистров, передача параметров и так далее.
  Стандартные требования к последовательности вызова применяются только
к глобальным функциям. Локальные функции, недоступные из других модулей
компиляции, могут использовать различные соглашения. Тем не менее,
рекомендуется, чтобы все функции использовали стандартную последовательность вызова,
когда это возможно.

    3.2.1 Регистры

Архитектура AMD64 обеспечивает 16 64-разрядных регистров общего назначения.
К тому же архитектура обеспечивает 16 регистров SSE, каждый шириной
128 бит и плавающий 8 x87 регистры точек, каждый шириной 80 бит. Каждый
из регистров с плавающей запятой x87 может быть упоминается в MMX/3DNow!
режим как 64-битный регистр. Все эти регистры глобальный для всех
процедур, активных для данного потока.

  Intel AVX (Advanced Vector Extensions) предоставляет 16 256-битных
регистров AVX registers (%ymm0-%ymm15).
Младшие 128 битов %ymm0-%ymm15 являются псевдонимами в соответствующих 
128-битных регистров SSE (%xmm0-%xmm15). Intel AVX-512 предоставляет
32 SIMD-регистра шириной 512 бит (%zmm0-%zmm31). Младшие 128 бит
%zmm0-%zmm31 привязаны к соответствующим 128-битным регистрам 
SSE (%xmm0-%xmm31 [5]). Нижние 256 битов %zmm0-%zmm31 связаны
с соответствующими 256-битными регистрами AVX (%ymm0-%ymm31 [6]).
Для целей передачи параметров и возврата из функции, %xmmN, %ymmN и %zmmN
относятся к одному и тому же регистру. Только один из них может быть
использован одновременно. Мы используем векторный регистр для обозначения
или SSE, AVX или AVX-512. Кроме того, Intel AVX-512 также обеспечивает
8 регистров векторной маски (%k0-%k7), каждый шириной 64 бита.
  В этом подразделе обсуждается использование каждого регистра.
Регистрирует %rbp, %rbx и %r12-%r15 «принадлежат» к вызывающей функции,
и вызываемая функция требуется сохранить свои ценности. Другими словами,
вызываемая функция должна сохранять значения этих регистров для
вызывающей стороны. Остальные регистры «принадлежат» вызываемым функция. [7] Если вызывающая функция хочет сохранить такое значение регистра
через вызов функции, он должен сохранить значение в своем локальном кадре стека.
______________________________________________________________________
[5] %xmm15-%xmm31 Доступны только Intel AVX-512 
[6] %ymm15-%ymm31 Доступны только Intel AVX-512 
[7] Обратите внимание, что в отличие от Intel386 ABI,% rdi и% rsi
относятся к вызываемой функции, а не вызывающей.
______________________________________________________________________

  Процессор должен находиться в режиме x87 при входе в функцию. Поэтому
каждая функция, которая использует регистры MMX, требует вызова emms или
femms инструкции после использования регистров MMX, перед возвратом или
вызовом другой функции.
  Флаг направления DF в регистре %rFLAGS должен быть очищен (установлен
в направлении "вперед") при входе и выходе функции. Другие пользовательские
флаги не имеют определенной роли в стандартной последовательности вызовов
и не сохраняется между вызовами. [8]
  Управляющие биты регистра MXCSR сохраняются вызываемой функцией (сохраняются до завершения процедуры), в то время как биты состояния сохраняются
вызывающей функцией (не сохраняются). Регистр слова состояния x87
сохраняется вызывающей функцией, тогда как управляющее слово x87
сохраняется вызываемой.

        3.2.2 Стековый кадр

В дополнение к регистрам каждая функция имеет кадр в стеке времени
выполнения. Этот стек растет вниз с высоких адресов. На рисунке 3.3
показана организация стека.

        Рисунок 3.3: Стековый кадр с указателем базы кадра
______________________________________________________________________
  Position        Contents                          Frame
______________________________________________________________________
8n+16(%rbp)       memory argument eightbyte n       
                  ...                               Previous
   16(%rbp)       memory argument eightbyte 0
______________________________________________________________________
    8(%rbp)       return address                
    0(%rbp)       previous %rbp value               Current
   -8(%rbp)       unspecified
                  ...
    0(%rsp)       variable size
 -128(%rsp)       red zone
______________________________________________________________________


Конец области входного аргумента должен быть выровнен по 16 (32 или 64,
если __m256 или __m512 передается по стеку) байтовой границы. Другими
словами, значение (%rsp+8) всегда кратно 16 (32 или 64), когда управление
передается в точку входа в функцию. Указатель стека, %rsp, всегда
указывает на конец последнего выделенного кадра стека. [9] 

______________________________________________________________________
[8] Все регистры x87 сохраняются вызывающей функцией, поэтому вызывающие
    функции использующие регистры MMX, могут использовать более быстрые
    инструкции femms.
[9] Обычного использования %rbp в качестве указателя для стекового
    кадра можно избежать, используя %rsp (указатель стека) для индексации
    в кадре стека. Эта техника сохраняет две инструкции в прологе и 
    эпилоге и делает доступным еще один регистр общего назначения (%rbp).
______________________________________________________________________

128-байтовая область за пределами местоположения, на которое указывает
%rsp, считается зарезервированным и не должен изменяться обработчиками
сигналов или прерываний. [10] Следовательно, функции могут использовать
эту область для временных данных, которые не нужны во время вызова
В частности, листовые функции могут использовать эту область для
всего кадра стека, вместо корректировки указателя стека в прологе и
эпилоге. Эта область известный как красная зона.

______________________________________________________________________
[10] Местоположения в пределах 128 байтов могут быть адресованы с помощью
однобайтовых смещений.
______________________________________________________________________


        3.2.3 Передача параметров

После того, как значения аргументов были вычислены, они помещаются в 
регистр и/или стек. Способ передачи значений описан в следующих разделах.

ОПРЕДЕЛЕНИЯ

Сначала мы определим ряд классов для классификации аргументов.

Классы соответствуют классам регистров AMD64 и определены как:

INTEGER      состоит из целых типы которые помещаются в
             регстры общего назначения.

SSE          состоит из типов которые помещаются в векторные регистры. 

SSEUP        состоит из типов которые помещаются в векторные регистры и
             могут быть переданы и возвращены в их старших байтах.

X87,X87UP    состоит из типов которые могут быть возвращены через x87 FPU
 
COMPLEX_X87  состоит из типов которые могут быть возвращены через x87 FPU

NO_CLASS     состоит из типов которые используются как инициализаторы
             в алгоритмах. Они могут использоватся для отступов и пустых
             структур и объединений.

MEMORY       состоит из типов которые могут передаваться или возвращатся
             в память через стек.


КЛАССИФИКАЦИЯ

Размер каждого аргумента округляется до восьми байт. [Поэтому стек всегда будет выровнен до восьми байтов.]

Основным типам присваиваются их естественные классы:

  * Аргументы типов (со знаком и без знака)
    _Bool, char, short, int, long, long long и указатели
    находятся в классе INTEGER.

  * Аргументы типов float, double, _Decimal32, _Decimal64 и __m64
    находятся в классе SSE.

  * Аргументы типов __float128, _Decimal128 и __m128
    разделены на две половины. Наименее значимые относятся к классу SSE,
    наиболее значительный для класса SSEUP.

  * Аргументы типа __m256
    разбиты на четыре восьмибайтовых блока. Один из них относится к
    классу SSE, а все остальные - к классу SSEUP.

  * Аргументы типа __m512 
    разбиты на восемь восьмибайтовых блоков. Один из них относится
    к классу SSE, а все остальные - к классу SSEUP.

  * 64-битная мантисса аргументов типа long double
    относится к классу X87, 16-битный показатель степени плюс 6 байтов
    заполнения принадлежит классу X87UP.

  * Аргументы типа __int128
    предлагают те же операции, что и INTEGER, все же они не вписываются
    в один регистр общего назначения, требуют двух регистров. В целях
    классификации __int128 обрабатывается так, как если бы он был
    реализован в виде:

    typedef struct {
      long low, high;
    } _int128;

    за исключением того, что аргументы типа __int128, которые хранятся
    в памяти должны быть выровнены по 16-байтовой границе.

  * Аргументы complex T, где T - один из типов float или double
    обрабатываются так, как будто они реализованы как:

    struct complexT {
      T real;
      T imag;
    };

  * Переменная типа complex long long классифицируется как тип COMPLEX_X87.

  Классификация агрегатных (структур и массивов) и объединений: 

  1. Если размер объекта больше восьми восьмибайтов, или он содержит
     выровненные поля, имеет класс MEMORY [12].

  2. Если объект C++ нетривиален для целей вызовов, как указано в C++ ABI
     [13], он передается по невидимой ссылке (объект заменяется в список
     параметров по указателю класса INTEGER) [14]. 

  3. Если размер агрегата превышает один восьмибайтовый, каждый
     классифицируется раздельно. Каждый восьмибайт инициализируется в
     классе NO_CLASS.

  4. Каждое поле объекта классифицируется рекурсивно, так что всегда
     считается два поля. Полученный класс рассчитывается в соответствии с
     классами поля в восемь байтов:
        (a) если оба класса одинаковы, то это результирующий класс.
        (b) если один из классов NO_CLASS, то будет другой класс как результат.
        (c) если одним из классов является MEMORY, результатом является
            класс MEMORY.
        (d) если один из классов - INTEGER, результатом является INTEGER.
        (e) если один из классов X87, X87UP, COMPLEX_X87 - класс MEMORY.
        (f) в противном случае используется класс SSE.
______________________________________________________________________
[12] Очистка после слияния, описанная ниже, гарантирует, что для
     процессоров, которые не поддерживают тип __m256, если размер
     объекта превышает два восьмибайта, а первые восемь байтов не SSE
     или любой другой восьмибайтовый не SSEUP, он все еще имеет класс
     MEMORY. Это в свою очередь гарантирует, что для процессоров,
     которые поддерживают тип __m256, если размер объекта составляет
     четыре восьмибайта и первые восемь байтов - это SSE, а все
     остальные восемь байтов - это SSEUP, его можно передать в регистр.
     Это также относится к типу __m512. Это для процессоров, которые
     поддерживают тип __m512, если размер объекта восемь восемь байтов,
     и первый восемь байтов SSE, а все остальные восемь байтов SSEUP,
     он может передается в регистр, в противном случае он будет передан
     в память. 13 См. Раздел 9.1 для получения подробной информации о
     C ++ ABI.
[13] См. Раздел 9.1 для получения подробной информации о C ++ ABI.
[14] Объект, тип которого нетривиален для целей вызовов, не может быть
     передан по значению, потому что такие объекты должны иметь один и
     тот же адрес в вызывающем и вызывающем объектах. Подобные проблемы
     применяются, когда возвращение объекта из функции. См. C ++ 17
     [class.teven] пункт 3.
______________________________________________________________________

  5. Затем выполняется очистка после слияния:
      (a) Если один из классов - MEMORY, весь аргумент передается в
          память.
      (b) Если X87UP не предшествует X87, весь аргумент передается в
          память.
      (c) Если размер агрегата превышает два восьмибайта, а первые
          восемь байт не SSE или любой другой восьмибайтовый не SSEUP,
          весь аргумент передается в память.
      (d) Если SSEUP не предшествует SSE или SSEUP, он преобразуется в SSE.


ПРЕДАЧА

После классификации аргументов регистры присваиваются (слева направо)
для передачи следующим образом:

  1. Если класс MEMORY, передайте аргумент в стек.
  2. Если класс INTEGER, то доступны регистры в последовательности
     %rdi, Используется %rsi, %rdx, %rcx, %r8 и %r9 [15].
  3. Если класс SSE, используется следующий доступный векторный регистр,
     регистры принимаются в порядке от% xmm0 до %xmm7.
  4. Если класс SSEUP, восемь байтов передаются в следующих доступных
     восьми байтотвом отрезке использованного векторного регистра.
  5. Если класс X87, X87UP или COMPLEX_X87, он передается в память.
  
Когда значение типа _Bool возвращается или передается в регистре или в
стеке, бит 0 содержит значение истинности, а биты с 1 по 7 должны быть
равны нулю [16]. 
______________________________________________________________________
[15] Обратите внимание, что %r11 не требуется для сохранения и не 
     используется для передачи аргументов. Делая этот регистр, доступный
     как скретч регистр, означает, что код в PLT не должен проливать
     какие-либо регистры при вычислении адреса, на который необходимо
     передать управление. %al используется для обозначения числа
     векторных аргументов, переданных функции, требующей переменного
     числа аргументов. %r10 используется для передачи статического
     указателя цепочки функции.

[16] Остальные биты остаются неопределенными, поэтому потребительская
     сторона этих значений может полагаться на 0 или 1 при усечении
     до 8 бит.
______________________________________________________________________


        Рисунок 3.4: Использование регистров.
______________________________________________________________________
 Регистр            Назначение                    Сохранение по вызову
______________________________________________________________________
%rax            временный регистр;                              NO 
                с переменной аргументом
                передающей информацию о числе использованных
                векторных регистров;
                1-й регистр возврата;
______________________________________________________________________
%rax            временный регистр;                              NO
______________________________________________________________________
%rbx            calle-saved регистр                             YES
______________________________________________________________________
%rcx            4-й аргумент функции                            NO
______________________________________________________________________
%rdx            3-й фргумент функции;                           NO
                2-й регистр возврата;
______________________________________________________________________
%rsp            Указатель стека                                 YES
______________________________________________________________________
%rbp            callee-saved;                                   YES
                Указатель базы текущего кадра стека (opt)
______________________________________________________________________
%rsi            2-й аргумент функции                            NO
______________________________________________________________________
%rdi            1-й аргумент функции                            NO
______________________________________________________________________
%r8             5-й агрумент функции                            NO
______________________________________________________________________
%r9             6-й аргумент функции                            NO
______________________________________________________________________
%r10            temp используется для передачи статичного       NO
                указателя цепочки функции
______________________________________________________________________
%r11            temp                                            NO
______________________________________________________________________
%r12-%r14       callee-saved                                    YES
______________________________________________________________________
%r15            callee-saved, опционально GOT указатель базы    YES
______________________________________________________________________
%xmm0-%xmm1     передача и возврат floating point аргумента     NO
______________________________________________________________________
%xmm2-%xmm7     передача floating point аргумент                NO
______________________________________________________________________
%xmm8-%xmm15    temp                                            NO
______________________________________________________________________
%mm0-%mm7       temp                                            NO
______________________________________________________________________
%k0-%k7         temp                                            NO
______________________________________________________________________
%st0-%st1       temp, возврат long double аргумента             NO
______________________________________________________________________
%fs             зарезервированно системой (thread specific)     NO
______________________________________________________________________
mxcsr           SSE2 солово состояния и управления            partial
______________________________________________________________________
x87 SW          x87 слово состояния                             NO
______________________________________________________________________
x87 CW          x87 слово управления                            YES
______________________________________________________________________

  Если для восьмибайтового аргумента нет доступных регистров, весь
аргумент передается в стеке. Если регистры уже были назначены для
некоторых восьмибайтов такого аргумента, назначения возвращаются.

Как только регистры назначены, аргументы, передаваемые в память,
передаются стек в обратном (справа налево [17]) порядке.

